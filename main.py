import sys
import requests
from bs4 import BeautifulSoup as bs
import re
from scapy.all import ARP, Ether, srp, IP, TCP, sr1
from PyQt5.QtWidgets import (QTextEdit, QApplication, QWidget, QPushButton, QVBoxLayout, QLabel, QLineEdit, QCheckBox, QTableWidget, QTableWidgetItem, QHBoxLayout, QMessageBox, QMainWindow, QProgressBar)
from urllib.parse import urljoin
from PyQt5.QtCore import QThread, pyqtSignal

class BruteforceThread(QThread):
    update_progress = pyqtSignal(int)
    add_result = pyqtSignal(str)

    def __init__(self, url, form_details, logins, passwords):
        super().__init__()
        self.url = url
        self.form_details = form_details
        self.logins = logins
        self.passwords = passwords

    def run(self):
        total_attempts = len(self.logins) * len(self.passwords)
        attempt_count = 0
        for login in self.logins:
            for password in self.passwords:
                response = self.submit_form(self.url, self.form_details, login, password)
                if not response:
                    self.add_result.emit("Error, not good form!")
                    return
                else:
                    if self.is_login_successful(response):
                        self.add_result.emit(f"Success: {login}/{password}")
                    attempt_count += 1
                    self.update_progress.emit(attempt_count)

    def submit_form(self, url, form_details, username, password):
        data = {}
        for name, value in form_details['inputs']:
            if not name:
                return None
            if "user" in name.lower():
                data[name] = username
            elif "password" in name.lower():
                data[name] = password
            else:
                data[name] = value
        if form_details['method'].lower() == 'post':
            response = requests.post(form_details['action'], data=data)
        else:
            response = requests.get(form_details['action'], params=data)
        return response

    def is_login_successful(self, response):
        if not response.history:
            return "welcome" in response.text.lower() 
        final_url = response.url.lower()
        error_terms = ['error', 'invalid', 'denied', 'failed']
        if any(term in final_url for term in error_terms):
            return False
        return True

class BruteforceWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setGeometry(100, 100, 500, 300)
        self.setWindowTitle('Bruteforce Login')

        layout = QVBoxLayout()
        self.url_label = QLabel('URL:')
        self.url_input = QLineEdit()
        self.start_button = QPushButton('Start Bruteforce')
        self.progress_bar = QProgressBar(self)
        self.result_text = QTextEdit()

        self.start_button.clicked.connect(self.start_bruteforce)

        layout.addWidget(self.url_label)
        layout.addWidget(self.url_input)
        layout.addWidget(self.start_button)
        layout.addWidget(self.progress_bar)
        layout.addWidget(self.result_text)
        self.setLayout(layout)

    def start_bruteforce(self):
        self.progress_bar.setVisible(True)
        url = self.url_input.text()
        if not url.startswith('http://') and not url.startswith('https://'):
            url = 'http://' + url
        logins = self.load_credentials('login.txt')
        passwords = self.load_credentials('password.txt')
        form_details = self.get_form_details(url)
        if not form_details:
            self.result_text.append("No form found at the URL.")
            return

        self.thread = BruteforceThread(url, form_details, logins, passwords)
        self.thread.update_progress.connect(self.progress_bar.setValue)
        self.thread.add_result.connect(self.result_text.append)
        total_attempts = len(logins) * len(passwords)
        self.progress_bar.setMaximum(total_attempts)
        self.thread.start()

    def load_credentials(self, filename):
        try:
            with open(filename, 'r') as file:
                return [line.strip() for line in file]
        except FileNotFoundError:
            self.result_text.append("Credential file not found.")
            return []

    def get_form_details(self, url):
        """ Extract form details required to make the POST request. """
        resp = requests.get(url)
        soup = bs(resp.text, 'html.parser')
        form = soup.find('form')
        if not form:
            return None
        
        details = {}
        action = form.attrs.get('action', '').strip() or url
        method = form.attrs.get('method', 'post').strip()
        inputs = []
        for input_tag in form.find_all('input'):
            input_type = input_tag.attrs.get('type', 'text')
            input_name = input_tag.attrs.get('name')
            input_value = input_tag.attrs.get('value', '')
            inputs.append((input_name, input_value))
        details['action'] = urljoin(url, action)
        details['method'] = method
        details['inputs'] = inputs
        return details


class SQLInjectionScanner(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
    
    def initUI(self):
        self.setGeometry(100, 100, 400, 200)
        self.setWindowTitle('SQL Injection Scanner')
        self.s = requests.Session()
        self.s.headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36"
        layout = QVBoxLayout()
        self.url_label = QLabel('Введите URL-адрес:')
        self.url_input = QLineEdit()
        self.scan_button = QPushButton('Начать анализ')
        self.scan_button.clicked.connect(self.start_scan)
        self.results_text = QTextEdit()

        layout.addWidget(self.url_label)
        layout.addWidget(self.url_input)
        layout.addWidget(self.scan_button)
        layout.addWidget(self.results_text)
        self.setLayout(layout)

    def start_scan(self):
        url = "http://" + self.url_input.text() if ("http://" not in self.url_input.text() and "https://" not in self.url_input.text())  else self.url_input.text()    
        if url:
            self.scan_sql_injection(url)
        else:
            QMessageBox.critical(self, "Ошибка", "URL не может быть пустым")

    def get_all_forms(self,url):
        """Given a `url`, it returns all forms from the HTML content"""
        soup = bs(self.s.get(url).content, "html.parser")
        return soup.find_all("form")
    
    def is_vulnerable(self,response):
        """A simple boolean function that determines whether a page 
        is SQL Injection vulnerable from its `response`"""
        errors = {
            # MySQL
            "you have an error in your sql syntax;",
            "warning: mysql",
            # SQL Server
            "unclosed quotation mark after the character string",
            # Oracle
            "quoted string not properly terminated",
        }
        for error in errors:
            # if you find one of these errors, return True
            if error in response.content.decode().lower():
                return True
        # no error detected
        return False
    
    def scan_sql_injection(self, url):
        self.results_text.append(f"Scanning {url} for SQL Injection vulnerabilities...")
        # Основная проверка уязвимости по URL
        for c in "\"'":
            test_url = f"{url}{c}"
            try:
                response = self.s.get(test_url)
                if self.is_vulnerable(response):
                    self.results_text.append(f"[+] SQL Injection vulnerability detected, link: {test_url}")
                    return
            except requests.exceptions.RequestException as e:
                pass

        # Получение всех форм
        forms = self.get_all_forms(url)
        if not forms:
            self.results_text.append("No forms found on this URL.")
            return

        self.results_text.append(f"[+] Detected {len(forms)} forms on {url}.")
        for form in forms:
            form_details = self.get_form_details(form, url)  # Передаем базовый URL для правильной обработки action
            # Имитация отправки формы с каждым типом кавычек
            for c in "\"'":
                data = {}
                for input_tag in form_details["inputs"]:
                    if input_tag["type"] == "submit":
                        continue  # Пропускаем кнопки отправки формы
                    input_value = input_tag.get("value", "") + c
                    data[input_tag["name"]] = input_value

                form_action = urljoin(url, form_details["action"]) if form_details["action"] else url
                if form_details["method"] == "post":
                    response = self.s.post(form_action, data=data)
                else:
                    response = self.s.get(form_action, params=data)
                if self.is_vulnerable(response):
                    self.results_text.append(f"[+] SQL Injection vulnerability detected at {form_action}")
                    break
                else:
                    self.results_text.append("[-] No SQL Injection vulnerability detected at this form.")

    def get_form_details(self, form, base_url):
        action = form.attrs.get("action", "")
        method = form.attrs.get("method", "get").lower()
        inputs = []
        for input_tag in form.find_all("input"):
            input_type = input_tag.attrs.get("type", "text")
            input_name = input_tag.attrs.get("name")
            input_value = input_tag.attrs.get("value", "")
            if input_type == 'submit' and action == '#':
                action = f'?{input_name}={input_value}&Submit=Submit'
            inputs.append({"type": input_type, "name": input_name, "value": input_value})
        return {"action": action, "method": method, "inputs": inputs}
class NetworkScannerWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
    
    def initUI(self):
        self.setGeometry(100, 100, 700, 400)
        self.setWindowTitle('Network Scanner')

        # Layouts
        layout = QVBoxLayout()
        form_layout = QHBoxLayout()

        # Input for IP range
        self.ip_range_label = QLabel('Введите IP-адрес сети:')
        self.ip_range_input = QLineEdit()
        form_layout.addWidget(self.ip_range_label)
        form_layout.addWidget(self.ip_range_input)

        # Checkboxes (mutually exclusive)
        self.scan_ports_checkbox = QCheckBox('Сканирование открытых портов')
        self.scan_mac_checkbox = QCheckBox('Сканирование MAC-адресов сети')
        self.scan_ports_checkbox.toggled.connect(self.toggle_checkboxes)
        self.scan_mac_checkbox.toggled.connect(self.toggle_checkboxes)
        layout.addLayout(form_layout)
        layout.addWidget(self.scan_ports_checkbox)
        layout.addWidget(self.scan_mac_checkbox)

       


        # Scan button
        self.scan_button = QPushButton('Начать сканирование')
        self.scan_button.clicked.connect(self.start_scan)
        layout.addWidget(self.scan_button)


        self.progress_bar = QProgressBar(self)
        self.progress_bar.setVisible(False)
        self.progress_bar.setGeometry(200, 80, 250, 20)
        layout.addWidget(self.progress_bar)

        # Table for results
        self.results_table = QTableWidget()
        self.results_table.setVisible(False)
        layout.addWidget(self.results_table)

        self.setLayout(layout)

    def toggle_checkboxes(self, checked):
        source = self.sender()
        if source == self.scan_ports_checkbox and checked:
            self.scan_mac_checkbox.setChecked(False)
            self.setup_table(['Порт', 'Открыт/Закрыт'])
        elif source == self.scan_mac_checkbox and checked:
            self.scan_ports_checkbox.setChecked(False)
            self.setup_table(['IP-адрес', 'MAC-адрес'])

    def setup_table(self, headers):
        self.results_table.setColumnCount(len(headers))
        self.results_table.setHorizontalHeaderLabels(headers)
        self.results_table.clearContents()
        self.results_table.setRowCount(0)
        self.results_table.setVisible(True)

    def start_scan(self):
        self.results_table.setRowCount(0)
        ip_address = self.ip_range_input.text()

        self.progress_bar.setVisible(True)
        operations_count = 23 if self.scan_ports_checkbox.isChecked() else 1
        self.progress_bar.setMaximum(operations_count)
        self.progress_bar.setValue(0)

        if self.scan_ports_checkbox.isChecked():
            self.scan_ports(ip_address)
        elif self.scan_mac_checkbox.isChecked():
            self.scan_mac(ip_address)

        self.progress_bar.setValue(self.progress_bar.maximum())

    def scan_ports(self, ip):
        if not self.validate_ip(ip):
            QMessageBox.critical(self, "Ошибка", "Неверный формат IP-адреса")
            return
        ports = [
            20, 21,     # FTP Data and Command
            22,         # SSH
            23,         # Telnet
            25,         # SMTP
            53,         # DNS
            80,         # HTTP
            110,        # POP3
            111,        # RPCbind
            135,        # MSRPC
            139,        # NetBIOS
            143,        # IMAP
            443,        # HTTPS
            445,        # Microsoft-DS (SMB)
            993,        # IMAP SSL
            995,        # POP3 SSL
            1723,       # PPTP VPN
            3306,       # MySQL
            3389,       # Remote Desktop
            5432,       # PostgreSQL
            5900,       # VNC
            8080,       # HTTP Proxy/Alt HTTP
            8443        # HTTPS Alt
        ]
        for i, port in enumerate(ports):
            QApplication.processEvents()
            self.progress_bar.setValue(i + 1)
            pkt = sr1(IP(dst=ip)/TCP(dport=port, flags="S"), timeout=1, verbose=0)
            status = 'Открыт' if pkt and TCP in pkt and pkt[TCP].flags & 18 else 'Закрыт'
            self.add_row_to_table(str(port), status)

    def scan_mac(self, ip):
        packet = Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(pdst=ip)
        ans, _ = srp(packet, timeout=2, verbose=0, iface_hint=ip)
        for sent, received in ans:
            self.add_row_to_table(received.psrc, received.hwsrc)

    def validate_ip(self, ip):
        pattern = re.compile(r"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$")
        return pattern.match(ip)
    
    def add_row_to_table(self, column_one, column_two):
        row_position = self.results_table.rowCount()
        self.results_table.insertRow(row_position)
        self.results_table.setItem(row_position, 0, QTableWidgetItem(column_one))
        self.results_table.setItem(row_position, 1, QTableWidgetItem(column_two))


class PenTestTools(QMainWindow):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle('Pentest Tools v1.0')
        self.setGeometry(100, 100, 600, 300)
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)

        # Layout
        layout = QVBoxLayout()

        # Creating buttons
        self.btn_network_scanner = QPushButton('Сканер сети')
        self.btn_network_scanner.clicked.connect(self.open_network_scanner)
        self.btn_bruteforce = QPushButton('Брутфорс')
        self.btn_bruteforce.clicked.connect(self.open_bruteforce)
        self.btn_sql_injection = QPushButton('Проверка на SQL-инъекцию')
        self.btn_sql_injection.clicked.connect(self.open_sql_scanner)
        self.btn_exit = QPushButton('Выход из приложения')

        # Adding buttons to layout
        layout.addWidget(self.btn_network_scanner)
        layout.addWidget(self.btn_bruteforce)
        layout.addWidget(self.btn_sql_injection)
        layout.addWidget(self.btn_exit)

        # Setting layout
        self.central_widget.setLayout(layout)

        # Connect buttons
        self.btn_exit.clicked.connect(self.close)  # Closes the application

    def close_application(self):
        self.close()
    
    def open_network_scanner(self):
        self.network_scanner_window = NetworkScannerWindow()
        self.network_scanner_window.show()
    
    def open_sql_scanner(self):
        self.sql_scanner_window = SQLInjectionScanner()
        self.sql_scanner_window.show()
    
    def open_bruteforce(self):
        self.bruteforce_window = BruteforceWindow()
        self.bruteforce_window.show()


def main():
    app = QApplication(sys.argv)
    ex = PenTestTools()
    ex.show()
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()
